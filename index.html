<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <!-- 设置 viewport，并增加 viewport-fit=cover 以充分利用屏幕空间 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>智能签名系统</title>
  <!-- Telegram Web App JS，用于 Telegram mini app 环境 -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <!-- 引入 LZString 库用于数据压缩（当数据过长时） -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
  <style>
    /* 全局重置与防止滚动 */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      overscroll-behavior: none;
      background: linear-gradient(135deg, #a8e063, #56ab2f);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    /* 居中容器 */
    body {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* 卡片式容器 */
    .container {
      background: #fff;
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
      width: 90%;
      max-width: 600px;
      padding: 20px;
      text-align: center;
      position: relative;
    }
    
    .container h2 {
      margin-top: 0;
      color: #333;
      font-size: 26px;
      font-weight: 600;
    }
    
    /* 签名画板区域 */
    .canvas-container {
      margin: 20px 0;
      border: 1px solid #ddd;
      border-radius: 12px;
      overflow: hidden;
      background: #fafafa;
    }
    
    canvas {
      width: 100%;
      height: auto;
      touch-action: none;
      display: block;
    }
    
    /* 按钮区域：使用自定义按钮 */
    .buttons {
      margin-top: 15px;
      display: flex;
      justify-content: center;
      gap: 15px;
    }
    
    .buttons button {
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.3s;
    }
    
    #clearButton {
      background: #ff6b6b;
      color: #fff;
    }
    
    #clearButton:hover {
      background: #ff5252;
    }
    
    #sendButton {
      background: #6c5ce7;
      color: #fff;
    }
    
    #sendButton:hover {
      background: #5f3dc4;
    }
    
    /* 反馈提示 */
    .feedback {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 12px 20px;
      border-radius: 8px;
      color: #fff;
      font-weight: bold;
      opacity: 0;
      transform: translateX(100%);
      transition: all 0.3s;
      z-index: 1000;
    }
    
    .feedback.show {
      opacity: 1;
      transform: translateX(0);
    }
    
    .feedback.success {
      background: #00b894;
    }
    
    .feedback.error {
      background: #d63031;
    }
    
    /* 状态提示 */
    .status-indicator {
      margin-top: 10px;
      color: #666;
      font-size: 14px;
    }
    
    /* 调试日志（生产环境可隐藏） */
    #debugLog {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      font-size: 12px;
      padding: 5px;
      z-index: 9999;
      box-sizing: border-box;
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>智能签名系统</h2>
    <div class="canvas-container">
      <canvas id="signatureCanvas"></canvas>
    </div>
    <div class="buttons">
      <button id="clearButton">清除</button>
      <button id="sendButton">发送轨迹</button>
    </div>
    <div class="status-indicator" id="statusIndicator"></div>
  </div>
  <div class="feedback" id="feedback"></div>
  <!-- 调试区域 -->
  <div id="debugLog"></div>

  <script>
    /********************
     * 签名绘制相关代码
     ********************/
    const canvas = document.getElementById('signatureCanvas');
    const ctx = canvas.getContext('2d');
    
    // 保存所有笔画（每笔为一系列点）
    let trajectories = [];
    let currentStroke = [];
    let drawing = false;
    let needsRedraw = false;
    
    // 根据容器宽度自适应调整 canvas 尺寸（采用 16:10 比例）
    function resizeCanvas() {
      const containerWidth = canvas.parentElement.clientWidth;
      canvas.width = containerWidth;
      canvas.height = containerWidth * 0.625;
      scheduleRedraw();
    }
    window.addEventListener('resize', resizeCanvas);
    document.addEventListener('DOMContentLoaded', resizeCanvas);
    
    // 利用 requestAnimationFrame 节流重绘
    function scheduleRedraw() {
      if (!needsRedraw) {
        needsRedraw = true;
        requestAnimationFrame(() => {
          redraw();
          needsRedraw = false;
        });
      }
    }
    
    // 获取 canvas 内坐标，并附加时间戳
    function getCanvasCoords(evt) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top,
        time: Date.now()
      };
    }
    
    // 重绘所有笔画：清空画布后重绘已完成和当前笔画
    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = '#333';
      
      trajectories.forEach(stroke => drawStroke(stroke));
      if (currentStroke.length > 0) {
        drawStroke(currentStroke);
      }
    }
    
    // 利用贝塞尔曲线平滑绘制笔画
    function drawStroke(stroke) {
      if (!stroke || stroke.length === 0) return;
      if (stroke.length < 2) {
        const p = stroke[0];
        ctx.beginPath();
        ctx.arc(p.x, p.y, ctx.lineWidth / 2, 0, Math.PI * 2);
        ctx.fill();
        return;
      }
      ctx.beginPath();
      ctx.moveTo(stroke[0].x, stroke[0].y);
      for (let i = 0; i < stroke.length - 1; i++) {
        const p0 = (i === 0) ? stroke[0] : stroke[i - 1];
        const p1 = stroke[i];
        const p2 = stroke[i + 1];
        const p3 = (i + 2 < stroke.length) ? stroke[i + 2] : p2;
        const cp1 = {
          x: p1.x + (p2.x - p0.x) / 6,
          y: p1.y + (p2.y - p0.y) / 6
        };
        const cp2 = {
          x: p2.x - (p3.x - p1.x) / 6,
          y: p2.y - (p3.y - p1.y) / 6
        };
        ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, p2.x, p2.y);
      }
      ctx.stroke();
    }
    
    // 开始绘制：记录第一个点
    function startDrawing(evt) {
      evt.preventDefault();
      drawing = true;
      currentStroke = [];
      currentStroke.push(getCanvasCoords(evt));
      scheduleRedraw();
    }
    
    // 绘制过程中记录点
    function continueDrawing(evt) {
      if (!drawing) return;
      evt.preventDefault();
      currentStroke.push(getCanvasCoords(evt));
      scheduleRedraw();
    }
    
    // 结束绘制：保存当前笔画，并重置状态
    function endDrawing(evt) {
      if (!drawing) return;
      evt.preventDefault();
      drawing = false;
      trajectories.push(currentStroke);
      currentStroke = [];
      scheduleRedraw();
    }
    
    // 绑定 Pointer 事件（支持鼠标、触摸及手写笔）
    canvas.addEventListener('pointerdown', startDrawing);
    canvas.addEventListener('pointermove', continueDrawing);
    canvas.addEventListener('pointerup', endDrawing);
    canvas.addEventListener('pointercancel', endDrawing);
    canvas.addEventListener('pointerleave', endDrawing);
    
    /********************
     * 反馈与调试
     ********************/
    function showFeedback(message, type) {
      const feedback = document.getElementById('feedback');
      const statusIndicator = document.getElementById('statusIndicator');
      feedback.textContent = message;
      feedback.className = `feedback ${type} show`;
      statusIndicator.textContent = message;
      setTimeout(() => {
        feedback.classList.remove('show');
        if (type === 'error') {
          statusIndicator.textContent = '';
        }
      }, 3000);
    }
    
    function logError(msg) {
      const debugLog = document.getElementById("debugLog");
      if (debugLog) {
        debugLog.textContent = msg;
      }
    }
    
    /********************
     * 按钮功能
     ********************/
    // 清除按钮：清空画板及签名数据
    document.getElementById('clearButton').addEventListener('click', () => {
      trajectories = [];
      currentStroke = [];
      redraw();
      document.getElementById('statusIndicator').textContent = '画板已清空';
    });
    
    // 发送按钮：将签名数据通过 Telegram API 发送给 Bot 服务端
    function sendDataToBot() {
      if (trajectories.length === 0) {
        showFeedback('请先进行签名', 'error');
        return;
      }
      const data = {
        trajectories: trajectories,
        exportedAt: new Date().toISOString()
      };
      let jsonData = JSON.stringify(data);
      logError("原始 jsonData 长度: " + jsonData.length);
      
      // 如果数据超过 4096 个字符，则尝试压缩
      if (jsonData.length > 4096) {
        const compressed = LZString.compressToEncodedURIComponent(jsonData);
        logError("压缩后数据长度: " + compressed.length);
        if (compressed.length <= 4096) {
          jsonData = compressed;
        } else {
          showFeedback("数据过长，即使压缩后仍超出限制", "error");
          logError("数据长度 " + compressed.length + " 超出限制");
          return;
        }
      }
      
      try {
        Telegram.WebApp.sendData(jsonData);
        showFeedback('轨迹已发送到 Telegram', 'success');
      } catch (e) {
        logError("sendData 错误: " + e.toString());
        showFeedback("发送失败: " + e.toString(), "error");
      }
    }
    
    // 绑定发送按钮事件
    document.getElementById('sendButton').addEventListener('click', sendDataToBot);
    
    /********************
     * Telegram mini app 初始化
     ********************/
    document.addEventListener('DOMContentLoaded', () => {
      Telegram.WebApp.ready();
    });
  </script>
</body>
</html>
